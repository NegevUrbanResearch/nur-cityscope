<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Map Projection</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
      #calibrationPanel {
        position: fixed;
        top: 10px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 15px;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        z-index: 10000;
        display: none;
      }
      #calibrationPanel h3 {
        margin-top: 0;
        margin-bottom: 10px;
      }
      #calibrationPanel p {
        margin: 5px 0;
        font-size: 14px;
      }
      .control-row {
        display: flex;
        justify-content: space-between;
        margin: 5px 0;
      }
      .control-button {
        background-color: #444;
        color: white;
        border: none;
        padding: 5px 10px;
        margin: 2px;
        border-radius: 3px;
        cursor: pointer;
      }
      .control-button:hover {
        background-color: #666;
      }
      .error-message {
        color: red;
        text-align: center;
        padding: 20px;
        font-family: Arial, sans-serif;
      }
      #keystoneContainer {
        width: 100%;
        height: 100%;
      }
      #displayedImage {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      #displayedVideo {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
    </style>
  </head>
  <body>
    <div id="keystoneContainer" class="keystoneContainer">
      <img id="displayedImage" src="" alt="Waiting for map..." />
      <video
        id="displayedVideo"
        autoplay
        loop
        muted
        playsinline
        style="display: none"
      ></video>
      <div id="errorMessage" class="error-message" style="display: none"></div>
      <div id="calibrationGrid" class="calibration-grid"></div>
    </div>

    <div id="calibrationPanel">
      <h3>Calibration Panel</h3>
      <p>
        <strong>Status:</strong>
        <span id="calibrationStatus">Configuration Mode OFF</span>
      </p>
      <div class="control-row">
        <button class="control-button" id="toggleConfigBtn">
          Toggle Config Mode (Shift+Z)
        </button>
      </div>
      <p>In config mode:</p>
      <ul>
        <li>Drag corners to warp projection</li>
        <li>Alt+drag to rotate/scale</li>
        <li>Arrow keys to move selected quad</li>
      </ul>
      <p><strong>Keyboard Shortcuts:</strong></p>
      <ul>
        <li><strong>R</strong> - Rotate 90Â°</li>
        <li><strong>H</strong> - Flip horizontal</li>
        <li><strong>V</strong> - Flip vertical</li>
        <li><strong>S</strong> - Solo/unsolo layer</li>
        <li><strong>C</strong> - Toggle crosshairs</li>
        <li><strong>B</strong> - Toggle bounds</li>
        <li><strong>X</strong> - Reset calibration</li>
        <li><strong>F</strong> - Fullscreen</li>
      </ul>
      <p>
        <em
          >Note: Calibration is automatically saved as you make adjustments.
          Press <strong>X</strong> to reset.</em
        >
      </p>
    </div>

    <script src="maptastic.js"></script>
    <script src="gallery.js"></script>

    <script>
      const $imagen = document.getElementById("displayedImage");
      const $video = document.getElementById("displayedVideo");
      const $errorMessage = document.getElementById("errorMessage");
      const $calibrationPanel = document.getElementById("calibrationPanel");
      const $calibrationStatus = document.getElementById("calibrationStatus");
      const $toggleConfigBtn = document.getElementById("toggleConfigBtn");

      // Initialize Maptastic for projection mapping
      // Only the keystoneContainer is registered - all content inside transforms with it
      const maptastic = Maptastic("keystoneContainer");
      let configActive = false;

      // Get the current origin (protocol + hostname) to handle both development and production
      const origin = window.location.origin;
      // Use relative paths for API requests
      const apiEndpoint = "/api/actions/get_image_data/";
      
      // Table management
      let currentTable = 'idistrict';
      let availableTables = [];
      
      // Fetch available tables
      async function fetchTables() {
        try {
          const response = await fetch('/api/tables/?is_active=true');
          if (response.ok) {
            const tables = await response.json();
            if (Array.isArray(tables)) {
              availableTables = tables;
              // Set current table to idistrict if available, otherwise first table
              const idistrictTable = tables.find(t => t.name === 'idistrict');
              currentTable = idistrictTable ? 'idistrict' : (tables[0]?.name || 'idistrict');
            }
          }
        } catch (error) {
          console.error('Error fetching tables:', error);
          currentTable = 'idistrict'; // Fallback
        }
      }
      
      // Fetch tables on load
      fetchTables();
      
      // WebSocket connection for real-time updates
      let ws = null;
      let wsReconnectTimeout = null;
      
      function connectWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/presentation/`;
        
        console.log('ðŸ”Œ Projection connecting to WebSocket:', wsUrl);
        
        try {
          ws = new WebSocket(wsUrl);
          
          ws.onopen = () => {
            console.log('âœ“ Projection WebSocket connected');
          };
          
          ws.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              
              // When indicator or presentation state changes, fetch new image
              if (message.type === 'indicator_update') {
                const data = message.data || {};
                
                console.log('ðŸ“¡ Projection: indicator update, fetching new content');
                updateImage();
              } else if (message.type === 'presentation_update') {
                console.log('ðŸ“¡ Projection: presentation update, fetching new content');
                updateImage();
              }
            } catch (err) {
              console.error('WebSocket message error:', err);
            }
          };
          
          ws.onclose = () => {
            console.log('âœ— Projection WebSocket disconnected, reconnecting...');
            clearTimeout(wsReconnectTimeout);
            wsReconnectTimeout = setTimeout(connectWebSocket, 3000);
          };
          
          ws.onerror = (error) => {
            console.error('Projection WebSocket error:', error);
          };
        } catch (err) {
          console.error('Projection WebSocket connection failed:', err);
          clearTimeout(wsReconnectTimeout);
          wsReconnectTimeout = setTimeout(connectWebSocket, 3000);
        }
      }
      
      // Connect to WebSocket on load
      connectWebSocket();

      function renderImagen(url) {
        if (isVideoFile(url)) {
          // Display as a video with looping
          $imagen.style.display = "none";
          $video.style.display = "block";

          // Only reload video if the URL has actually changed
          if ($video.src !== url) {
            $video.src = url;
            $video.load();
          }
        } else {
          // Display as an image
          $imagen.style.display = "block";
          $video.style.display = "none";
          $imagen.setAttribute("src", url);
        }

        $errorMessage.style.display = "none";
      }

      function isVideoFile(url) {
        if (!url) return false;
        const videoExtensions = [".mp4", ".webm", ".ogg", ".avi", ".mov"];
        return videoExtensions.some((ext) => url.toLowerCase().includes(ext));
      }

      function showError(message) {
        $errorMessage.textContent = message;
        $errorMessage.style.display = "block";
      }

      // Track current content to avoid unnecessary reloads
      let currentContent = null;
      let currentType = null;

      // Function to get and update the image
      function updateImage() {
        fetch(`${apiEndpoint}?table=${currentTable}`)
          .then((response) => {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
          })
          .then((data) => {
            if (data.image_data) {
              // Check if content has actually changed
              if (
                currentContent === data.image_data &&
                currentType === data.type
              ) {
                return; // No need to reload if content is the same
              }

              // Properly construct the media URL using origin
              const mediaUrl = `${origin}/media/${data.image_data}`;

              console.log("Image data received:", data.image_data);
              console.log("Type:", data.type);
              console.log("Media URL:", mediaUrl);

              // Update current content tracking
              currentContent = data.image_data;
              currentType = data.type;

              // Render the content (image or video)
              renderImagen(mediaUrl);
            } else if (data.error) {
              console.error("Error from API:", data.error);
              // Check if it's a 404 (no data available)
              if (data.error.includes("not found") || data.error.includes("No")) {
                showError("No visualization data available for the selected table. Please try selecting a different table.");
              } else {
                showError("Server error: " + data.error);
              }
            } else {
              console.error('No "image_data" found in API response');
              showError("No visualization data available for the selected table.");
            }
          })
          .catch((error) => {
            console.error("Error fetching data:", error);
            showError("Error loading visualization: " + error.message);
          });
      }

      // Toggle calibration config mode
      function toggleConfigMode() {
        configActive = !configActive;
        maptastic.setConfigEnabled(configActive);
        $calibrationStatus.textContent = configActive
          ? "Configuration Mode ON"
          : "Configuration Mode OFF";
        $calibrationPanel.style.display = configActive ? "block" : "none";

        // Show calibration grid when in config mode
        document.getElementById("calibrationGrid").style.display = configActive
          ? "block"
          : "none";
      }

      // Reset calibration to defaults
      function resetCalibration() {
        console.log("resetCalibration function called");
        if (confirm("Are you sure you want to reset the calibration?")) {
          console.log("User confirmed reset");
          localStorage.removeItem("maptastic.layers");
          console.log("Cleared localStorage");

          // Reset the maptastic layout to default without page reload
          if (maptastic && maptastic.getLayout) {
            const currentLayout = maptastic.getLayout();
            console.log("Current layout before reset:", currentLayout);

            // Reset each layer to default positions
            for (let i = 0; i < currentLayout.length; i++) {
              const layer = currentLayout[i];
              if (layer.targetPoints && layer.sourcePoints) {
                // Reset target points to match source points (no transformation)
                layer.targetPoints = layer.sourcePoints.map((point) => [
                  ...point,
                ]);
              }
            }

            console.log("Layout after reset:", currentLayout);
            maptastic.setLayout(currentLayout);
            console.log("Applied reset layout");
          }

          alert("Calibration reset to defaults!");
        } else {
          console.log("User cancelled reset");
        }
      }

      // Auto-reset calibration on page load to fix sideways display
      function autoResetCalibration() {
        // Only reset if there's problematic saved data
        const savedData = localStorage.getItem("maptastic.layers");
        if (savedData) {
          try {
            const layout = JSON.parse(savedData);
            // Check if any layer has been rotated 90 degrees (sideways)
            let hasProblematicRotation = false;

            for (let i = 0; i < layout.length; i++) {
              const layer = layout[i];
              if (layer.targetPoints && layer.sourcePoints) {
                // Check if the layer has been rotated 90 degrees
                // This is a simple heuristic - if the aspect ratio is significantly different
                const sourceWidth =
                  layer.sourcePoints[1][0] - layer.sourcePoints[0][0];
                const sourceHeight =
                  layer.sourcePoints[2][1] - layer.sourcePoints[0][1];
                const targetWidth =
                  layer.targetPoints[1][0] - layer.targetPoints[0][0];
                const targetHeight =
                  layer.targetPoints[2][1] - layer.targetPoints[0][1];

                const sourceRatio = sourceWidth / sourceHeight;
                const targetRatio = targetWidth / targetHeight;

                // If ratios are very different, it might be rotated
                if (Math.abs(sourceRatio - 1 / targetRatio) < 0.1) {
                  hasProblematicRotation = true;
                  break;
                }
              }
            }

            // Only reset if we detect problematic rotation
            if (hasProblematicRotation) {
              console.log("Detected sideways rotation, resetting to default");
              localStorage.removeItem("maptastic.layers");
            }
          } catch (error) {
            console.log("Error parsing saved data, clearing it");
            localStorage.removeItem("maptastic.layers");
          }
        }
      }

      // Event listeners for calibration panel
      $toggleConfigBtn.addEventListener("click", toggleConfigMode);

      // Fallback polling - WebSocket handles real-time updates
      setInterval(updateImage, 10000);

      // Auto-reset calibration to fix sideways display
      autoResetCalibration();

      // Initial update
      updateImage();

      // Keyboard event listener for calibration toggle and other shortcuts
      window.addEventListener("keydown", function (event) {
        // Shift+Z to toggle configuration mode
        if (event.key === "Z" && event.shiftKey) {
          toggleConfigMode();
        }

        // X key for reset calibration
        if (event.key === "X" || event.keyCode === 88) {
          console.log("X key pressed - resetting calibration");
          resetCalibration();
        }

        // F key for fullscreen
        if (event.keyCode === 70) {
          toggleFullScreen();
        }
      });
    </script>
  </body>
</html>
